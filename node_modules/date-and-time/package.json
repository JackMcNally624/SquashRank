{
  "_from": "date-and-time",
  "_id": "date-and-time@0.11.0",
  "_inBundle": false,
  "_integrity": "sha512-VyzhHurex4wlg9oMszn7O+kxHchphWjzDn7Mv0WfkFKI6hSNOQePpTBFGsnRakvLNzQKXqPBAVV8DOxUGtUxqA==",
  "_location": "/date-and-time",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "date-and-time",
    "fetchSpec": "latest",
    "name": "date-and-time",
    "raw": "date-and-time",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/date-and-time/-/date-and-time-0.11.0.tgz",
  "_shasum": "1e22b61533af303953d79cc8c5e92e228fc5e4d2",
  "_shrinkwrap": null,
  "_spec": "date-and-time",
  "_where": "C:\\Users\\jxm0624\\Desktop\\SquashRank",
  "author": {
    "name": "KNOWLEDGECODE"
  },
  "browser": {
    "date-and-time": "./date-and-time.js"
  },
  "bugs": {
    "url": "https://github.com/knowledgecode/date-and-time/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "A Minimalist DateTime utility for Node.js and the browser",
  "devDependencies": {
    "babel-preset-env": "^1.7.0",
    "babelify": "^7.3.0",
    "browserify": "^14.5.0",
    "expect.js": "^0.3.1",
    "mocha": "^5.2.0",
    "mocha-phantomjs-core": "^2.1.2",
    "phantomjs-prebuilt": "^2.1.16"
  },
  "homepage": "https://github.com/knowledgecode/date-and-time",
  "keywords": [
    "date",
    "format",
    "parse",
    "time",
    "utility"
  ],
  "license": "MIT",
  "main": "date-and-time.js",
  "name": "date-and-time",
  "optionalDependencies": {},
  "readme": "# date-and-time\n\n[![Circle CI](https://circleci.com/gh/knowledgecode/date-and-time.svg?style=shield)](https://circleci.com/gh/knowledgecode/date-and-time)  \n\nThis library is a minimalist collection of functions for manipulating JS date and time. It's tiny, simple, easy to learn.\n\n## Why\n\nJS modules nowadays are getting more huge and complex, and there are also many dependencies. Trying to keep each module simple and small is meaningful.\n\n## Features\n\n- Minimalist. Less than 2k. (minified and gzipped)\n- Extensible. Plugin system support.\n- Multi language support.\n- Universal / Isomorphic. Wherever JS runtime works.\n- Older browser support. Even works on IE6. :)\n\n## Install\n\n- via npm:\n\n```shell\nnpm install date-and-time --save\n```\n\n- local:\n\n```html\n<script src=\"/path/to/date-and-time.min.js\"></script>\n```\n\n## Recent Changes\n\n- 0.11.0\n  - Added a `compile()` function that precompiling a date string for the parser. In case of processing many date string with one format, by using this function, you could be able to get results faster than before.\n\n  ```javascript\n  // We have passed a string format at the 2nd parameter every time when calling the parse() function.\n  date.parse('Mar. 22 2019 2:54:21 p.m.', 'MMM. D YYYY h:m:s A');\n  date.parse('Jul. 27 2019 4:15:24 a.m.', 'MMM. D YYYY h:m:s A');\n  date.parse('Dec. 25 2019 3:51:11 a.m.', 'MMM. D YYYY h:m:s A');\n\n  // You can precompile the string format.\n  const pattern = date.compile('MMM. D YYYY h:m:s A');\n\n  // The parse() will be able to finish faster than passing the format string every time.\n  date.parse('Mar. 22 2019 2:54:21 p.m.', pattern);\n  date.parse('Jul. 27 2019 4:15:24 a.m.', pattern);\n  date.parse('Dec. 25 2019 3:51:11 a.m.', pattern);\n  ```\n\n  ```javascript\n  const pattern = date.compile('MMM. D YYYY h:m:s A');\n\n  // The isValid() will also too.\n  date.isValid('Mar. 22 2019 2:54:21 p.m.', pattern);\n  ```\n\n- 0.10.0\n  - The `YYYY` token has come to require 4 digits in the `parse()`, the `preparse()` and the `isValid()` (**Breaking Change**).\n\n  ```javascript\n  date.parse('31-12-0123', 'DD-MM-YYYY');   // Good\n  date.parse('31-12-123', 'DD-MM-YYYY');    // Not good\n  ```\n\n  - The `YY` token has come to require 2 digits in the above functions (**Breaking Change**).\n\n  ```javascript\n  date.parse('31-12-03', 'DD-MM-YY');   // Good, but It's interpreted the year is 2003.\n  date.parse('31-12-3', 'DD-MM-YY');    // Not good\n  ```\n\n  - Added a `Y` token to support year, 4 or less digits in the above functions. This new token, `Y` is equivalent to the previous `YYYY` token.\n\n  ```javascript\n  date.parse('31-12-123', 'DD-MM-Y');   // Good\n  date.parse('31-12-3', 'DD-MM-Y');     // Good\n  ```\n\n- 0.9.0 (Locale Update)\n  - Renewal of the locale system. Some functions were merged (**Breaking Change**).\n  - Added a plugin system. You could extend a formatter and a parser by using this mechanism.\n  - With the addition of the plugin system, the `format()` has come to accept a user original token.\n\n- 0.8.0 (Parser Update)\n  - The `parse()` has come to return `Invalid Date` instead of `NaN` when parsing is failure (**Breaking Change**).\n  - Added `preparse()`. It returns a Date Structure.\n  - The `isValid()` has come to take a Date Structure in addition to a date string.\n  - The `isLeapYear()` has come to take a year (number type) instead of a Date object (**Breaking Change**).\n\n## Usage\n\n- Node.js:\n\n```javascript\nconst date = require('date-and-time');\n```\n\n- With a transpiler:\n\n```javascript\nimport date from 'date-and-time';\n```\n\n- With an older browser:\n\n```javascript\nwindow.date;    // global object\n```\n\n## API\n\n### format(dateObj, formatString[, utc])\n\n- Formatting a date.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**string**} formatString - a format string\n  - @param {**boolean**} [utc] - output as UTC\n  - @returns {**string**} a formatted string\n\n```javascript\nconst now = new Date();\ndate.format(now, 'YYYY/MM/DD HH:mm:ss');    // => '2015/01/02 23:14:05'\ndate.format(now, 'ddd., MMM. DD YYYY');     // => 'Fri., Jan. 02 2015'\ndate.format(now, 'hh:mm A [GMT]Z');         // => '11:14 p.m. GMT-0800'\ndate.format(now, 'hh:mm A [GMT]Z', true);   // => '07:14 a.m. GMT+0000'\n```\n\nAvailable tokens and their meanings are as follows:\n\n| token        | meaning     | example           |\n|:-------------|:------------|:------------------|\n| YYYY         | year        | 0999, 2015        |\n| YY           | year        | 05, 99            |\n| Y            | year        | 2, 44, 888, 2015  |\n| MMMM         | month       | January, December |\n| MMM          | month       | Jan, Dec          |\n| MM           | month       | 01, 12            |\n| M            | month       | 1, 12             |\n| DDD (*)      | day         | 1st, 2nd, 3rd     |\n| DD           | day         | 02, 31            |\n| D            | day         | 2, 31             |\n| dddd         | day of week | Friday, Sunday    |\n| ddd          | day of week | Fri, Sun          |\n| dd           | day of week | Fr, Su            |\n| HH           | 24-hour     | 23, 08            |\n| H            | 24-hour     | 23, 8             |\n| A            | meridiem    | a.m., p.m.        |\n| a (*)        | meridiem    | A.M., P.M.        |\n| AA (*)       | meridiem    | AM, PM            |\n| aa (*)       | meridiem    | am, pm            |\n| hh           | 12-hour     | 11, 08            |\n| h            | 12-hour     | 11, 8             |\n| mm           | minute      | 14, 07            |\n| m            | minute      | 14, 7             |\n| ss           | second      | 05, 10            |\n| s            | second      | 5, 10             |\n| SSS          | millisecond | 753, 022          |\n| SS           | millisecond | 75, 02            |\n| S            | millisecond | 7, 0              |\n| Z            | timezone    | +0100, -0800      |\n\n(*) Not available by default. See [PLUGINS.md](./PLUGINS.md) for details.\n\n#### NOTE 1. Comments\n\nStrings in parenthese `[...]` in the `formatString` will be ignored as comments:\n\n```javascript\ndate.format(new Date(), 'DD-[MM]-YYYY');    // => '02-MM-2015'\ndate.format(new Date(), '[DD-[MM]-YYYY]');  // => 'DD-[MM]-YYYY'\n```\n\n#### NOTE 2. Output as UTC\n\nThis function usually outputs a local date-time string. Set to true a `utc` option (the 3rd parameter) if you would like to get a UTC date/time string.\n\n```javascript\ndate.format(new Date(), 'hh:mm A [GMT]Z');          // => '11:14 p.m. GMT-0800'\ndate.format(new Date(), 'hh:mm A [GMT]Z', true);    // => '07:14 a.m. GMT+0000'\n```\n\n#### NOTE 3. More Tokens\n\nYou could also define your own tokens. See [PLUGINS.md](./PLUGINS.md) for details.\n\n---\n\n### compile(formatString)\n\n- Compiling a format string for the parser.\n  - @param {**string**} formatString - a format string\n  - @returns {**Array.\\<string\\>**} a compiled object\n\n```javascript\n  const pattern = date.compile('MMM. D YYYY h:m:s A');\n\n  date.parse('Mar. 22 2019 2:54:21 p.m.', pattern);\n  date.parse('Jul. 27 2019 4:15:24 a.m.', pattern);\n  date.parse('Dec. 25 2019 3:51:11 a.m.', pattern);\n```\n\nIf you are going to call the `parse()` or the `isValid()` many times with one string format, recommended to precompile and reuse it for performance.\n\n---\n\n### parse(dateString, arg[, utc])\n\n- Parsing a date string.\n  - @param {**string**} dateString - a date string\n  - @param {**string|Array.\\<string\\>**} arg - a format string or a compiled object\n  - @param {**boolean**} [utc] - input as UTC\n  - @returns {**Date**} a constructed date\n\n```javascript\ndate.parse('2015/01/02 23:14:05', 'YYYY/MM/DD HH:mm:ss');   // => Jan. 2 2015 23:14:05 GMT-0800\ndate.parse('02-01-2015', 'DD-MM-YYYY');                     // => Jan. 2 2015 00:00:00 GMT-0800\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A');                  // => Jan. 1 1970 23:14:05 GMT-0800\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A', true);            // => Jan. 1 1970 15:14:05 GMT-0800\ndate.parse('Jam. 1 2017', 'MMM. D YYYY');                   // => Invalid Date\ndate.parse('Feb. 29 2016', 'MMM. D YYYY');                  // => Feb. 29 2016 00:00:00 GMT-0800\ndate.parse('Feb. 29 2017', 'MMM. D YYYY');                  // => Invalid Date\n```\n\nAvailable tokens and their meanings are as follows:\n\n| token        | meaning     | example           |\n|:-------------|:------------|:------------------|\n| YYYY         | year        | 0999, 2015        |\n| YY           | year        | 05, 99            |\n| Y            | year        | 2, 44, 88, 2015   |\n| MMMM         | month       | January, December |\n| MMM          | month       | Jan, Dec          |\n| MM           | month       | 01, 12            |\n| M            | month       | 1, 12             |\n| DD           | day         | 02, 31            |\n| D            | day         | 2, 31             |\n| HH           | 24-hour     | 23, 08            |\n| H            | 24-hour     | 23, 8             |\n| hh           | 12-hour     | 11, 08            |\n| h            | 12-hour     | 11, 8             |\n| A            | meridiem    | a.m., p.m.        |\n| A (*)        | meridiem    | A.M., P.M.        |\n| A (*)        | meridiem    | AM, PM            |\n| A (*)        | meridiem    | am, pm            |\n| mm           | minute      | 14, 07            |\n| m            | minute      | 14, 7             |\n| ss           | second      | 05, 10            |\n| s            | second      | 5, 10             |\n| SSS          | millisecond | 753, 022          |\n| SS           | millisecond | 75, 02            |\n| S            | millisecond | 7, 0              |\n\n(*) Not available by default. See [PLUGINS.md](./PLUGINS.md) for details.\n\n#### NOTE 1. Invalid Date\n\nIf the function fails to parse, it will return `Invalid Date`. Notice that the `Invalid Date` is a Date object, not `NaN` or `null`. You could tell whether the Date object is invalid as follows:\n\n```javascript\nconst today = date.parse('Jam. 1 2017', 'MMM. D YYYY');\n\nif (isNaN(today)) {\n    // Failure\n}\n```\n\n#### NOTE 2. Input as UTC\n\nThis function usually assumes the `dateString` is local date-time. Set to true a `utc` option (the 3rd parameter) if it is UTC.\n\n```javascript\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A');          // => Jan. 1 1970 23:14:05 GMT-0800\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A', true);    // => Jan. 1 1970 15:14:05 GMT-0800\n```\n\n#### NOTE 3. Default Date Time\n\nDefault date is `January 1, 1970`, time is `00:00:00.000`. Values not passed will be complemented with them:\n\n```javascript\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A');  // => Jan. 1 1970 23:14:05 GMT-0800\ndate.parse('Feb. 2000', 'MMM. YYYY');       // => Feb. 1 2000 00:00:00 GMT-0800\n```\n\n#### NOTE 4. Max Date / Min Date\n\nParsable maximum date is `December 31, 9999`, minimum date is `January 1, 0001`.\n\n```javascript\ndate.parse('Dec. 31 9999', 'MMM. D YYYY');  // => Dec. 31 9999 00:00:00 GMT-0800\ndate.parse('Dec. 31 10000', 'MMM. D YYYY'); // => Invalid Date\n\ndate.parse('Jan. 1 0001', 'MMM. D YYYY');   // => Jan. 1 0001 00:00:00 GMT-0800\ndate.parse('Jan. 1 0000', 'MMM. D YYYY');   // => Invalid Date\n```\n\n#### NOTE 5. Auto Mapping\n\nThe `YY` token maps the year 69 or less to the 2000s, the year 70 or more to the 1900s. Using it is not recommended.\n\n```javascript\ndate.parse('Dec. 31 00', 'MMM. D YY');  // => Dec. 31 2000 00:00:00 GMT-0800\ndate.parse('Dec. 31 69', 'MMM. D YY');  // => Dec. 31 2069 00:00:00 GMT-0800\ndate.parse('Dec. 31 70', 'MMM. D YY');  // => Dec. 31 1970 00:00:00 GMT-0800\ndate.parse('Dec. 31 99', 'MMM. D YY');  // => Dec. 31 1999 00:00:00 GMT-0800\n```\n\n#### NOTE 6. 12-hour notation and Meridiem\n\nIf use the `hh` or `h` (12-hour) token, use together the `A` (meridiem) token to get the right value.\n\n```javascript\ndate.parse('11:14:05', 'hh:mm:ss');         // => Jan. 1 1970 11:14:05 GMT-0800\ndate.parse('11:14:05 p.m.', 'hh:mm:ss A');  // => Jan. 1 1970 23:14:05 GMT-0800\n```\n\n#### NOTE 7. Comments\n\nStrings in parenthese `[...]` in the formatString will be ignored as comments:\n\n```javascript\ndate.parse('12 hours 34 minutes', 'HH hours mm minutes');       // => Invalid Date\ndate.parse('12 hours 34 minutes', 'HH [hours] mm [minutes]');   // => Jan. 1 1970 12:34:00 GMT-0800\n```\n\nAs a white space works as a wild card, you could also write as follows:\n\n```javascript\ndate.parse('12 hours 34 minutes', 'HH       mm        ');   // => Jan. 1 1970 12:34:00 GMT-0800\n```\n\n---\n\n### preparse(dateString, arg)\n\n- Pre-parsing a date string.\n  - @param {**string**} dateString - a date string\n  - @param {**string|Array.\\<string\\>**} arg - a format string or a compiled object\n  - @returns {**Object**} a date structure\n\nThis function takes exactly the same parameters with the `parse()`, but returns a date structure as follows unlike it:\n\n```javascript\ndate.preparse('2015/01/02 23:14:05', 'YYYY/MM/DD HH:mm:ss');\n\n{\n    Y: 2015,        // Year\n    M: 1,           // Month\n    D: 2,           // Day\n    H: 23,          // 24-hour\n    A: 0,           // Meridiem\n    h: 0,           // 12-hour\n    m: 14,          // Minute\n    s: 5,           // Second\n    S: 0,           // Millisecond\n    _index: 19,     // Pointer offset\n    _length: 19,    // Length of the date string\n    _match: 6       // Token matching count\n}\n```\n\nThis object shows a parsing result. You would be able to tell from it how the date string was parsed(, or why the parsing was failed).\n\n---\n\n### isValid(arg1[, arg2])\n\n- Validation.\n  - @param {**Object|string**} arg1 - a date structure or a date string\n  - @param {**string|Array.\\<string\\>**} [arg2] - a format string or a compiled object\n  - @returns {**boolean**} whether the date string is a valid date\n\nThis function takes either exactly the same parameters with the `parse()` or a date structure which the `preparse()` returns, evaluates the validity of them.\n\n```javascript\ndate.isValid('2015/01/02 23:14:05', 'YYYY/MM/DD HH:mm:ss'); // => true\ndate.isValid('29-02-2015', 'DD-MM-YYYY');                   // => false\n\nconst result = date.preparse('2015/01/02 23:14:05', 'YYYY/MM/DD HH:mm:ss');\ndate.isValid(result);   // => true\n```\n\n---\n\n### addYears(dateObj, years)\n\n- Adding years.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} years - number of years to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst next_year = date.addYears(now, 1);\n```\n\n---\n\n### addMonths(dateObj, months)\n\n- Adding months.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} months - number of months to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst next_month = date.addMonths(now, 1);\n```\n\n---\n\n### addDays(dateObj, days)\n\n- Adding days.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} days - number of days to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst yesterday = date.addDays(now, -1);\n```\n\n---\n\n### addHours(dateObj, hours)\n\n- Adding hours.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} hours - number of hours to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst an_hour_ago = date.addHours(now, -1);\n```\n\n---\n\n### addMinutes(dateObj, minutes)\n\n- Adding minutes.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} minutes - number of minutes to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst two_minutes_later = date.addMinutes(now, 2);\n```\n\n---\n\n### addSeconds(dateObj, seconds)\n\n- Adding seconds.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} seconds - number of seconds to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst three_seconds_ago = date.addSeconds(now, -3);\n```\n\n---\n\n### addMilliseconds(dateObj, milliseconds)\n\n- Adding milliseconds.\n  - @param {**Date**} dateObj - a Date object\n  - @param {**number**} milliseconds - number of milliseconds to add\n  - @returns {**Date**} a date after adding the value\n\n```javascript\nconst now = new Date();\nconst a_millisecond_later = date.addMilliseconds(now, 1);\n```\n\n---\n\n### subtract(date1, date2)\n\n- Subtracting.\n  - @param {**Date**} date1 - a Date object\n  - @param {**Date**} date2 - a Date object\n  - @returns {**Object**} a result object subtracting date2 from date1\n\n```javascript\nconst today = new Date(2015, 0, 2);\nconst yesterday = new Date(2015, 0, 1);\n\ndate.subtract(today, yesterday).toDays();           // => 1 = today - yesterday\ndate.subtract(today, yesterday).toHours();          // => 24\ndate.subtract(today, yesterday).toMinutes();        // => 1440\ndate.subtract(today, yesterday).toSeconds();        // => 86400\ndate.subtract(today, yesterday).toMilliseconds();   // => 86400000\n```\n\n---\n\n### isLeapYear(y)\n\n- Leap year.\n  - @param {**number**} y - year\n  - @returns {**boolean**} whether the year is a leap year\n\n```javascript\ndate.isLeapYear(2015);  // => false\ndate.isLeapYear(2012);  // => true\n```\n\n---\n\n### isSameDay(date1, date2)\n\n- Comparison of two dates.\n  - @param {**Date**} date1 - a Date object\n  - @param {**Date**} date2 - a Date object\n  - @returns {**boolean**} whether the dates are the same day (times are ignored)\n\n```javascript\nconst date1 = new Date(2017, 0, 2, 0);          // Jan. 2 2017 00:00:00\nconst date2 = new Date(2017, 0, 2, 23, 59);     // Jan. 2 2017 23:59:00\nconst date3 = new Date(2017, 0, 1, 23, 59);     // Jan. 1 2017 23:59:00\ndate.isSameDay(date1, date2);   // => true\ndate.isSameDay(date1, date3);   // => false\n```\n\n---\n\n### locale([code[, locale]])\n\n- Change locale or setting a new locale definition.\n  - @param {**string**} [code] - language code\n  - @param {**Object**} [locale] - locale definition\n  - @returns {**string**} current language code\n\nReturns current language code if called without any parameters.\n\n```javascript\ndate.locale();  // \"en\"\n```\n\nTo switch to any other language, call it with a language code.\n\n```javascript\ndate.locale('es');  // Switch to Spanish\n```\n\nTo define a new locale, call it with new language code and a locale definition. See [LOCALE.md](./LOCALE.md) for details.\n\n---\n\n### extend(extension)\n\n- Locale extension.\n  - @param {**Object**} extension - locale definition\n  - @returns {**void**}\n\nExtends a current locale (formatter and parser). See [PLUGINS.md](./PLUGINS.md) for details.\n\n---\n\n### plugin(name[, extension])\n\n- Plugin import or definition.\n  - @param {**string**} name - plugin name\n  - @param {**Object**} [extension] - locale definition\n  - @returns {**void**}\n\nPlugin is a named locale definition defined with the `extend()`. See [PLUGINS.md](./PLUGINS.md) for details.\n\n---\n\n## Browser Support\n\nChrome, Firefox, Safari, Edge, and Internet Explorer 6+.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/knowledgecode/date-and-time.git"
  },
  "scripts": {
    "compile": "./compile.sh date-and-time.js date-and-time.min.js",
    "test": "./test.sh"
  },
  "version": "0.11.0"
}
